memory.c : réécrire les fonctions nécessaires
(notamment caml_modify)

fail.c : réécrire les fonctions nécessaires
	- des appels à caml_alloc_small (fonction dans memory.c)
	faire directement des Alloc_small ?
	- quelques utilisations de Max_young_wosize & co 
	(références aux tas majeurs/mineurs inéxistants maintenant)
	- un caml_copy_string (fonction dans alloc.c)

stacks.c : réécrire les fonctions nécessaires
	- initialisation (*en gros* : alloc)
	- changement de taille (*en gros* : realloc)
	- changement de la taille max (utile ?)

dans le GC : 
	- parcourir le bloc (si c'en est un) pointé par : accu, env
	- parcourir tableau des global root
	- infix_tag : pour les fonctions mutuellement réccursives :
		pour appeler une fonction qui est stockée au milieu d'un bloc....

nouvelle idée pour le GC :
	struct {
	value* accu;
	value** sp;
	value* caml_exn_bucket;
	} gc_datas;
	on initialise les bons champs aux bons endroits.
	et on parcour cette structure lorsque qu'on lance le GC.
	(et ca permet de virer *sp de Alloc_small, ce qui lui rendra sa généricité)
	yolo
	

io.c/h : s'en débarasser ?

intern.c : virer les 3/4 des fonctions?

intern.c :
	 intern_alloc : faire juste un Alloc_small ?
	 voir intern_alloc(whsize, num_objects) dans caml_input_val
	 voir la valeur de retour
